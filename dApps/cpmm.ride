{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let version = "1.0.0"
let keyVersion = "version"
let keyActive = "active"
let keyAssetIdA = "A_asset_id"
let keyAssetIdB = "B_asset_id"
let keyBalanceA = "A_asset_balance"
let keyBalanceB = "B_asset_balance"
let keyBalanceInitA = "A_asset_init"
let keyBalanceInitB = "B_asset_init"
let keyShareAssetId = "share_asset_id"
let keyShareAssetSupply = "share_asset_supply"
let keyCommission = "commission"
let keyCommissionScaleDelimiter = "commission_scale_delimiter"
let keyCause = "shutdown_cause"
let keyFirstHarvest = "first_harvest"
let keyFirstHarvestHeight = "first_harvest_height"
let kShareLimit = "share_limit_on_first_harvest"
let kBasePeriod = "base_period"
let kPeriodLength = "period_length"
let kStartHeight = "start_height"
let kFirstHarvestHeight = "first_harvest_height"
let keyUSDNNSBTAddress = "staking_usdnnsbt_address"
let keyEURNAddress = "staking_eurn_address"
let keyLeasingPool = "leasing_address"
let keyLeasingAmount = "leasing_amount"
let keyLeasingId = "leasing_id"


let keyAdminPubKey1 = "admin_pub_1"
let keyAdminPubKey2 = "admin_pub_2"
let keyAdminPubKey3 = "admin_pub_3"

#TODO change address
let oracle = Address(base58'3PEbqViERCoKnmcSULh6n2aiMvUdSQdCsom')
func getAdminPub(keyAdminPub: String) = match oracle.getString(keyAdminPub) {
    case string: String => string.fromBase58String()
    case nothing => throw("Admin public key is empty")
}

let adminPubKey1 = getAdminPub(keyAdminPubKey1)
let adminPubKey2 = getAdminPub(keyAdminPubKey2)
let adminPubKey3 = getAdminPub(keyAdminPubKey3)

let adminPubKeyStartStop = base58'EtVkT6ed8GtbUiVVEqdmEqsp2J4qbb3rre2HFgxeVYdg'
let adminPubKeyStaking = base58'Czn4yoAuUZCVCLJDRfskn8URfkwpknwBTZDbs1wFrY7h'
let walletAddress = Address(base58'3P6J84oH51DzY6xk2mT5TheXRbrCwBMxonp')
let votingAddress = Address(base58'3PQZWxShKGRgBN1qoJw6B4s9YWS9FneZTPg')

let USDN = base58'DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p'
let SWOP = base58'Ehie5xYpeN8op1Cctc6aGUrqx8jq3jtf1DSjXDbfm7aT'
let EURN = base58'DUk2YTxhRoAqMJLus4G2b3fR8hMHVh6eiyFx5r29VR6t'

let stakingAssets = ["WAVES", USDN.toBase58String(), EURN.toBase58String()]
let stakingUSDNAddress = Address(oracle.getString(keyUSDNNSBTAddress).valueOrErrorMessage("no usdn staking address").fromBase58String())
let stakingEURNAddress = Address(oracle.getString(keyEURNAddress).valueOrErrorMessage("no eurn staking address").fromBase58String())

let USDNToWavesExchanger = Address(base58'3PHaNgomBkrvEL2QnuJarQVJa71wjw9qiqG')

let basePeriod = votingAddress.getInteger(kBasePeriod).valueOrErrorMessage("Empty kBasePeriod") # 0
let startHeight = votingAddress.getInteger(kStartHeight).valueOrErrorMessage("Empty kStartHeight")
let periodLength =  votingAddress.getInteger(kPeriodLength).valueOrErrorMessage("Empty kPeriodLength")  # 10102

let firstHarvestEndPeriod = basePeriod + (height-startHeight)/periodLength + 3
let active = this.getBooleanValue(keyActive)

let strAssetIdA = this.getStringValue(keyAssetIdA)
let strAssetIdB = this.getStringValue(keyAssetIdB)
let assetIdA = if strAssetIdA == "WAVES" then unit else strAssetIdA.fromBase58String()
let assetIdB = if strAssetIdB == "WAVES" then unit else strAssetIdB.fromBase58String()
let assetNameA = match assetIdA {
    case id: ByteVector => assetInfo(id).value().name
    case waves: Unit => "WAVES"
}
let assetNameB = match assetIdB {
    case id: ByteVector => assetInfo(id).value().name
    case waves: Unit => "WAVES"
}

let balanceA = this.getIntegerValue(keyBalanceA)
let balanceB = this.getIntegerValue(keyBalanceB)
let shareAssetId = this.getStringValue(keyShareAssetId).fromBase58String()
let shareAssetSupply = this.getIntegerValue(keyShareAssetSupply)

let commission = 3000 # commission/commissionScaleDelimiter = 0.003
let commissionGovernance = 1200 # commissionGovernance/commissionScaleDelimiter = 0.0012
let commissionScaleDelimiter = 1000000

let scaleValue3 = 1000
let scaleValue8 = 100000000
let slippageToleranceDelimiter = 1000
let scaleValue8Digits = 8

func accountBalance(assetId: ByteVector|Unit) = match assetId {
    case id: ByteVector => this.assetBalance(id)
    case waves: Unit => this.wavesBalance().available
}

func stakedAmount(assetId: ByteVector|Unit) = {
    let stakedAmountCalculated = match assetId {
        case aId: ByteVector =>
          if aId == USDN then {
              stakingUSDNAddress.getInteger("rpd_balance_" + aId.toBase58String() + "_" + this.toString())
          } else if  aId == EURN then {
              stakingEURNAddress.getInteger("%s%s%s__stakingBalance__" + aId.toBase58String() + "__" + this.toString())
          } else 0
        case _:Unit => this.getInteger(keyLeasingAmount).valueOrElse(0)
      }
    match (stakedAmountCalculated) {
        case i:Int => i
        case _ => 0
    }
}

let stakedAmountA = stakedAmount(assetIdA)
let stakedAmountB = stakedAmount(assetIdB)

let assetInitA = this.getIntegerValue(keyBalanceInitA)
let assetInitB = this.getIntegerValue(keyBalanceInitB)

let availableBalanceA = balanceA - stakedAmountA
let availableBalanceB = balanceB - stakedAmountB
let accountBalanceWithStakedA = accountBalance(assetIdA) + stakedAmountA
let accountBalanceWithStakedB = accountBalance(assetIdB) + stakedAmountB

let hasEnoughBalance = accountBalanceWithStakedA >= balanceA && accountBalanceWithStakedB >= balanceB
func getAssetInfo(assetId: ByteVector|Unit) = match assetId {
    case id: ByteVector =>
        let stringId = id.toBase58String()
        let info = assetInfo(id).valueOrErrorMessage("Asset " + stringId + " doesn't exist")
        (stringId, info.name, info.decimals)
    case waves: Unit => ("WAVES", "WAVES", 8)
}

func getAssetInfoFromString(assetStr: String) = {
    if assetStr == "WAVES" then ("WAVES", "WAVES", 8)
    else {
        let stringId = assetStr
        let id = assetStr.fromBase58String()
        let info = assetInfo(id).valueOrErrorMessage("Asset " + stringId + " doesn't exist")
        (stringId, info.name, info.decimals)
    }
}

func suspend(cause: String) = [
    BooleanEntry(keyActive, false),
    StringEntry(keyCause, cause)
]

func calcStakingFuncAndAddres(stake: Boolean, assetId: ByteVector) = {
    if stake then
        if assetId == USDN then ("lockNeutrino", stakingUSDNAddress)
        else ("startStaking", stakingEURNAddress)
    else
        if assetId == USDN then ("unlockNeutrino", stakingUSDNAddress)
        else ("stopStaking", stakingEURNAddress)
}

func calcStakingParams(stake: Boolean, amount:Int, assetId: ByteVector) = {
    if stake then
        let (call, stakingAddr) = calcStakingFuncAndAddres(stake, assetId)
        (call, stakingAddr, [], [AttachedPayment(assetId, amount)])
    else
        let (call, stakingAddr) = calcStakingFuncAndAddres(stake, assetId)
        (call, stakingAddr, [amount, assetId.toBase58String()], [])
}

func calculateFees(pmtAmount: Int, minAmountToReceive: Int, tokenFrom: Int, tokenTo: Int) = {
    let amountWithoutFee = fraction(tokenTo, pmtAmount, pmtAmount + tokenFrom)
    let amountWithFee = fraction(amountWithoutFee, commissionScaleDelimiter - commission, commissionScaleDelimiter)
    let governanceReward = fraction(amountWithoutFee, commissionGovernance, commissionScaleDelimiter)

    if amountWithFee < minAmountToReceive then
        throw("Calculated amount to receive " + amountWithFee.toString() + " is less than specified minimum " + minAmountToReceive.toString())
    else
        (amountWithoutFee, amountWithFee, governanceReward)
}

func suspendSuspicious() = suspend("Suspicious state. Actual balances: " + accountBalanceWithStakedA.toString() + " " + assetNameA + ", " + accountBalanceWithStakedB.toString() + " " + assetNameB
    + ". State: " + balanceA.toString() + " " + assetNameA + ", " + balanceB.toString() + " " + assetNameB)

func isActive() = if active then unit else throw("DApp is inactive at this moment")

@Callable(i)
func init(firstHarvest: Boolean) = {
    let (pmtAmountA, pmtAssetIdA) = (i.payments[0].amount, i.payments[0].assetId)
    let (pmtAmountB, pmtAssetIdB) = (i.payments[1].amount, i.payments[1].assetId)
    let (pmtStrAssetIdA, pmtAssetNameA, pmtDecimalsA) = getAssetInfo(pmtAssetIdA)
    let (pmtStrAssetIdB, pmtAssetNameB, pmtDecimalsB) = getAssetInfo(pmtAssetIdB)

    if ![adminPubKey1, adminPubKey2, adminPubKey3, adminPubKeyStaking].containsElement(i.callerPublicKey) then
        throw("Only admin can call this function")
    else if this.getBoolean(keyActive).isDefined() then
        throw("DApp is already active")
    else if pmtAssetIdA == pmtAssetIdB then
        throw("Assets must be different")
    else {
        let shareName = "s" + pmtAssetNameA.take(7) + "_" + pmtAssetNameB.take(7)
        let shareDescription = "ShareToken of SwopFi protocol for " + pmtAssetNameA + " and " + pmtAssetNameB + " at address " + this.toString()

        let shareDecimals = (pmtDecimalsA + pmtDecimalsB) / 2

        let arg1 = pow(pmtAmountA, pmtDecimalsA, 5, 1, pmtDecimalsA, DOWN)
        let arg2 = pow(pmtAmountB, pmtDecimalsB, 5, 1, pmtDecimalsB, DOWN)
        let arg3 = pow(10, 0, shareDecimals, 0, 0, DOWN)

        let shareInitialSupply = fraction(
            arg1,arg2,arg3
        )

        let shareIssue = Issue(shareName, shareDescription, shareInitialSupply, shareDecimals, true)
        let shareIssueId = shareIssue.calculateAssetId()
        strict stake1 = if stakingAssets.containsElement(pmtStrAssetIdA) then
                invoke(this, "stakeUnstake", [true, pmtAmountA, pmtStrAssetIdA], []) else 0
            strict stake2 = if stakingAssets.containsElement(pmtStrAssetIdB) then
                invoke(this, "stakeUnstake", [true, pmtAmountB, pmtStrAssetIdB], []) else 0
        let baseEntry =         [
            StringEntry(keyVersion, version),
            BooleanEntry(keyActive, true),
            StringEntry(keyAssetIdA, pmtStrAssetIdA),
            StringEntry(keyAssetIdB, pmtStrAssetIdB),
            IntegerEntry(keyBalanceA, pmtAmountA),
            IntegerEntry(keyBalanceB, pmtAmountB),
            IntegerEntry(keyCommission, commission),
            IntegerEntry(keyCommissionScaleDelimiter, commissionScaleDelimiter),
            shareIssue,
            StringEntry(keyShareAssetId, shareIssueId.toBase58String()),
            IntegerEntry(keyShareAssetSupply, shareInitialSupply),
            ScriptTransfer(i.caller, shareInitialSupply, shareIssueId)
        ]
        if (firstHarvest) then {
            baseEntry ++ [
                BooleanEntry(keyFirstHarvest, firstHarvest),
                IntegerEntry(keyFirstHarvestHeight, startHeight + firstHarvestEndPeriod * periodLength)
            ]
        } else {
            baseEntry
        }
    }
}

@Callable(i)
func initWithInitRatio(amtAssetA: Int, amtAssetB: Int, strAssetIdA: String, strAssetIdB: String, firstHarvest: Boolean) = {
    let (pmtStrAssetIdA, pmtAssetNameA, pmtDecimalsA) = getAssetInfoFromString(strAssetIdA)
    let (pmtStrAssetIdB, pmtAssetNameB, pmtDecimalsB) = getAssetInfoFromString(strAssetIdB)

    if ![adminPubKey1, adminPubKey2, adminPubKey3, adminPubKeyStaking].containsElement(i.callerPublicKey) then
        throw("Only admin can call this function")
    else if this.getBoolean(keyActive).isDefined() then
        throw("DApp is already active")
    else if strAssetIdA == strAssetIdB then
        throw("Assets must be different")
    else {
        let shareName = "s" + pmtAssetNameA.take(7) + "_" + pmtAssetNameB.take(7)
        let shareDescription = "ShareToken of SwopFi protocol for " + pmtAssetNameA + " and " + pmtAssetNameB + " at address " + this.toString()

        let shareDecimals = (pmtDecimalsA + pmtDecimalsB) / 2
        let shareInitialSupply = 0
        let shareIssue = Issue(shareName, shareDescription, shareInitialSupply, shareDecimals, true)
        let shareIssueId = shareIssue.calculateAssetId()
        let baseEntry =         [
            StringEntry(keyVersion, version),
            BooleanEntry(keyActive, true),
            StringEntry(keyAssetIdA, pmtStrAssetIdA),
            StringEntry(keyAssetIdB, pmtStrAssetIdB),
            IntegerEntry(keyBalanceInitA, amtAssetA),
            IntegerEntry(keyBalanceInitB, amtAssetB),
            IntegerEntry(keyBalanceA, 0),
            IntegerEntry(keyBalanceB, 0),
            IntegerEntry(keyCommission, commission),
            IntegerEntry(keyCommissionScaleDelimiter, commissionScaleDelimiter),
            shareIssue,
            StringEntry(keyShareAssetId, shareIssueId.toBase58String()),
            IntegerEntry(keyShareAssetSupply, shareInitialSupply)
        ]

        if (firstHarvest) then {
            baseEntry ++ [
                BooleanEntry(keyFirstHarvest, firstHarvest),
                IntegerEntry(keyFirstHarvestHeight, startHeight + firstHarvestEndPeriod * periodLength)
            ]
        } else {
            baseEntry
        }
    }
}

@Callable(i)
func keepLimitForFirstHarvest(shareLimit: Int) = isActive().valueOrElse({
    if ![adminPubKey1, adminPubKey2, adminPubKey3, adminPubKeyStaking].containsElement(i.callerPublicKey) then
        throw("Only admin can call this function")
    else
        [
            IntegerEntry(kShareLimit, shareLimit)
        ]
})

@Callable(i)
func replenishWithTwoTokens(slippageTolerance: Int) = isActive().valueOrElse({
    let pmtAssetIdA = i.payments[0].assetId
    let pmtAssetIdB = i.payments[1].assetId
    let pmtAmountA = i.payments[0].amount
    let pmtAmountB = i.payments[1].amount
    let (pmtStrAssetIdA, pmtAssetNameA, pmtDecimalsA) = getAssetInfo(pmtAssetIdA)
    let (pmtStrAssetIdB, pmtAssetNameB, pmtDecimalsB) = getAssetInfo(pmtAssetIdB)
    let inital = if (balanceA == 0 && balanceB == 0) then true else false

    let tokenRatio = if inital then
            fraction(assetInitA, scaleValue8, pmtAmountA)
                .fraction(scaleValue3, assetInitB.fraction(scaleValue8, pmtAmountB))
        else
            fraction(balanceA, scaleValue8, pmtAmountA)
                .fraction(scaleValue3, balanceB.fraction(scaleValue8, pmtAmountB))
    let shareDecimals = (pmtDecimalsA + pmtDecimalsB) / 2
    let shareTokenToPayAmount = if inital then fraction(
                pow(pmtAmountA, pmtDecimalsA, 5, 1, pmtDecimalsA, DOWN),
                pow(pmtAmountB, pmtDecimalsB, 5, 1, pmtDecimalsB, DOWN),
                pow(10, 0, shareDecimals, 0, 0, DOWN)
            )
        else
            min([fraction(pmtAmountA, scaleValue8, balanceA), fraction(pmtAmountB, scaleValue8, balanceB)])
                .fraction(shareAssetSupply, scaleValue8)

    if slippageTolerance < 0 || slippageTolerance > slippageToleranceDelimiter then
        throw("Slippage tolerance must be between 0 and " + slippageToleranceDelimiter.toString() + " inclusively. Actual: " + slippageTolerance.toString())
    else if i.payments.size() != 2 then
        throw("Two attached assets expected")
    else if pmtAssetIdA != assetIdA || pmtAssetIdB != assetIdB then
        throw("Incorrect assets attached. Expected: " + strAssetIdA + " and " + strAssetIdB)
    else if tokenRatio < (scaleValue3 * (slippageToleranceDelimiter - slippageTolerance)) / slippageToleranceDelimiter
            || tokenRatio > (scaleValue3 * (slippageToleranceDelimiter + slippageTolerance)) / slippageToleranceDelimiter then
        throw("Incorrect assets amount: amounts must have the contract ratio")
    else if shareTokenToPayAmount == 0 then
        throw("Too small amount to replenish")
    else if !hasEnoughBalance then
        [
            ScriptTransfer(i.caller, pmtAmountA, pmtAssetIdA),
            ScriptTransfer(i.caller, pmtAmountB, pmtAssetIdB)
        ] ++ suspendSuspicious()
    else
        strict stake1 = if stakingAssets.containsElement(pmtStrAssetIdA) then
                    invoke(this, "stakeUnstake", [true, pmtAmountA, pmtStrAssetIdA], []) else 0
        strict stake2 = if stakingAssets.containsElement(pmtStrAssetIdB) then
            invoke(this, "stakeUnstake", [true, pmtAmountB, pmtStrAssetIdB], []) else 0
        [
            Reissue(shareAssetId, shareTokenToPayAmount, true),
            IntegerEntry(keyBalanceA, balanceA + pmtAmountA),
            IntegerEntry(keyBalanceB, balanceB + pmtAmountB),
            IntegerEntry(keyShareAssetSupply, shareAssetSupply + shareTokenToPayAmount),
            ScriptTransfer(i.caller, shareTokenToPayAmount, shareAssetId)
        ]
})

@Callable(i)
func withdraw() = isActive().valueOrElse({
    let (pmtAmount, pmtAssetId) = (i.payments[0].amount, i.payments[0].assetId)
    let amountToPayA = pmtAmount.fraction(balanceA, shareAssetSupply)
    let amountToPayB = pmtAmount.fraction(balanceB, shareAssetSupply)

    if i.payments.size() != 1 then
        throw("One attached payment expected")
    else if pmtAssetId != shareAssetId then
        throw("Incorrect asset attached. Expected: " + shareAssetId.toBase58String())
    else if !hasEnoughBalance then
        [
            ScriptTransfer(i.caller, pmtAmount, pmtAssetId)
        ] ++ suspendSuspicious()
    else
        strict stake1 = if stakingAssets.containsElement(strAssetIdA) then
            invoke(this, "stakeUnstake", [false, amountToPayA, strAssetIdA], []) else 0
        strict stake2 = if stakingAssets.containsElement(strAssetIdB) then
            invoke(this, "stakeUnstake", [false, amountToPayB, strAssetIdB], []) else 0
        [
            IntegerEntry(keyBalanceA, balanceA - amountToPayA),
            IntegerEntry(keyBalanceB, balanceB - amountToPayB),
            IntegerEntry(keyShareAssetSupply, shareAssetSupply - pmtAmount),
            Burn(shareAssetId, pmtAmount),
            ScriptTransfer(i.caller, amountToPayA, assetIdA),
            ScriptTransfer(i.caller, amountToPayB, assetIdB)
        ]
})

@Callable(i)
func exchange(minAmountToReceive: Int) = isActive().valueOrElse({
    let (pmtAmount, pmtAssetId) = (i.payments[0].amount, i.payments[0].assetId)



    if balanceA == 0 || balanceB == 0 then
        throw("Can't exchange with zero balance")
    else if minAmountToReceive <= 0 then
        throw("Minimal amount to receive must be positive. Actual: " + minAmountToReceive.toString())
    else if i.payments.size() != 1 then
        throw("One attached payment expected")
    else if !hasEnoughBalance then
        [
            ScriptTransfer(i.caller, pmtAmount, pmtAssetId)
        ] ++ suspendSuspicious()
    else if pmtAssetId == assetIdA then {
        let assetIdSend = assetIdB

        let (amountWithoutFee, amountWithFee, governanceReward) = calculateFees(pmtAmount, minAmountToReceive, balanceA, balanceB)

        let newBalanceA = balanceA + pmtAmount
        let newBalanceB = balanceB - amountWithFee - governanceReward

        # successful execution result is updating information about actual balance and supply into the state and transfer tokens to the caller
        strict stake1 = if stakingAssets.containsElement(strAssetIdA) then
            invoke(this, "stakeUnstake", [true, pmtAmount, strAssetIdA], []) else 0
        strict stake2 = if stakingAssets.containsElement(strAssetIdB) then
            invoke(this, "stakeUnstake", [false, amountWithFee + governanceReward, strAssetIdB], []) else 0
        [
            IntegerEntry(keyBalanceA, newBalanceA),
            IntegerEntry(keyBalanceB, newBalanceB),
            ScriptTransfer(i.caller, amountWithFee, assetIdSend),
            ScriptTransfer(walletAddress, governanceReward, assetIdSend)
        ]
    } else if pmtAssetId == assetIdB then {
        let assetIdSend = assetIdA
        let (amountWithoutFee, amountWithFee, governanceReward) = calculateFees(pmtAmount, minAmountToReceive, balanceB, balanceA)

        let newBalanceA = balanceA - amountWithFee - governanceReward
        let newBalanceB = balanceB + pmtAmount
        strict stake1 = if stakingAssets.containsElement(strAssetIdA) then
        invoke(this, "stakeUnstake", [false, amountWithFee + governanceReward, strAssetIdA], []) else 0
        strict stake2 = if stakingAssets.containsElement(strAssetIdB) then
            invoke(this, "stakeUnstake", [true, pmtAmount, strAssetIdB], []) else 0
        [
            IntegerEntry(keyBalanceA, newBalanceA),
            IntegerEntry(keyBalanceB, newBalanceB),
            ScriptTransfer(i.caller, amountWithFee, assetIdSend),
            ScriptTransfer(walletAddress, governanceReward, assetIdSend)
        ]
    } else
        throw("Incorrect asset attached. Expected: " + strAssetIdA + " or " + strAssetIdB)
})

@Callable(i)
func shutdown() =
    if !active then
        throw("DApp is already suspended. Cause: " + this.getString(keyCause).valueOrElse("the cause wasn't specified"))
    else if ![adminPubKey1, adminPubKey2, adminPubKey3, adminPubKeyStartStop].containsElement(i.callerPublicKey) then
        throw("Only admin can call this function")
    else
        suspend("Paused by admin")

@Callable(i)
func activate() =
    if active then
        throw("DApp is already active")
    else if ![adminPubKey1, adminPubKey2, adminPubKey3, adminPubKeyStartStop].containsElement(i.callerPublicKey) then
        throw("Only admin can call this function")
    else [
        BooleanEntry(keyActive, true),
        DeleteEntry(keyCause)
    ]
@Callable(i)
func takeIntoAccountExtraFunds() = isActive().valueOrElse({
    let amountEnrollA = accountBalanceWithStakedA - balanceA
    let amountEnrollB = accountBalanceWithStakedB - balanceB

    if i.caller != walletAddress then
        throw("Only the wallet can call this function")
    else if amountEnrollA < 0 || amountEnrollB < 0 then
        suspend("Enroll amount negative")
    else if amountEnrollA == 0 && amountEnrollB == 0 then
        throw("No money to take")
    else
        strict stake1 = if stakingAssets.containsElement(strAssetIdA) then
            invoke(this, "stakeUnstake", [true, amountEnrollA, strAssetIdA], []) else 0
        strict stake2 = if stakingAssets.containsElement(strAssetIdB) then
            invoke(this, "stakeUnstake", [true, amountEnrollB, strAssetIdB], []) else 0
        [
            IntegerEntry(keyBalanceA, balanceA + amountEnrollA),
            IntegerEntry(keyBalanceB, balanceB + amountEnrollB),
            IntegerEntry("last_income_"+strAssetIdA, amountEnrollA),
            IntegerEntry("last_income_"+strAssetIdB, amountEnrollB)
        ]
})

@Callable(i)
func stakeUnstake(stake:Boolean, amount: Int, assetIdString:String) = {
    if i.caller != this then
        throw("Only contract itself can invoke this function")
    else
        if assetIdString == "WAVES" then
            let pool = oracle.getString(keyLeasingPool).valueOrErrorMessage("No leasing pool in oracle").addressFromStringValue()
            let leasingId = this.getBinary(keyLeasingId)
            let leasingAmount = this.getInteger(keyLeasingAmount).valueOrElse(0)
            let newLeaseAmount = if stake then leasingAmount + amount else leasingAmount - amount
            let newLease = Lease(pool, newLeaseAmount)
            let newLeaseId = newLease.calculateLeaseId()
            let baseEtry = [
                newLease,
                BinaryEntry(keyLeasingId, newLeaseId),
                IntegerEntry(keyLeasingAmount, newLeaseAmount)
            ]
            match (leasingId) {
                case lId: ByteVector =>  [LeaseCancel(lId)] ++ baseEtry
                case _ => baseEtry
            }
        else
            let (call, addr, params, payments) = calcStakingParams(stake, amount, assetIdString.fromBase58String())
            strict inv = invoke(addr, call, params, payments)
            []
}

@Callable(i)
func stakeAll() = isActive().valueOrElse({
    if ![adminPubKey1, adminPubKey2, adminPubKey3, adminPubKeyStartStop].containsElement(i.callerPublicKey) then
        throw("Only admin can call this function")
    else
        strict stake1 =
            if stakingAssets.containsElement(strAssetIdA) then
                let amountA = balanceA - stakedAmountA
                if amountA > 0 then
                    invoke(this, "stakeUnstake", [true, amountA, strAssetIdA], [])  else 0
            else 0
        strict stake2 =
            if stakingAssets.containsElement(strAssetIdB) then
                let amountB = balanceB - stakedAmountB
                if amountB > 0 then
                    invoke(this, "stakeUnstake", [true, amountB, strAssetIdB], []) else 0
            else 0
        []
})

@Verifier(tx)
func verify() = {
  let multiSignedByAdmins = {
        let adminPubKey1Signed = if sigVerify(tx.bodyBytes, tx.proofs[0], adminPubKey1) then 1 else 0
        let adminPubKey2Signed = if sigVerify(tx.bodyBytes, tx.proofs[1], adminPubKey2) then 1 else 0
        let adminPubKey3Signed = if sigVerify(tx.bodyBytes, tx.proofs[2], adminPubKey3) then 1 else 0
        adminPubKey1Signed + adminPubKey2Signed + adminPubKey3Signed >= 2
  }
  match tx {
      case inv: InvokeScriptTransaction =>
        let callTakeIntoAccount = inv.dApp == this && inv.function == "takeIntoAccountExtraFunds"
        let exchangeToWaves =
            inv.dApp == USDNToWavesExchanger
            && inv.function == "exchange"
            && inv.payments.size() == 1
            && (inv.payments[0].assetId == USDN || inv.payments[0].assetId == unit)
        let signedByAdmin =
            sigVerify(tx.bodyBytes, tx.proofs[0], adminPubKey1)
            || sigVerify(tx.bodyBytes, tx.proofs[0], adminPubKey2)
            || sigVerify(tx.bodyBytes, tx.proofs[0], adminPubKey3)
            || sigVerify(tx.bodyBytes, tx.proofs[0], adminPubKeyStaking)

        ((callTakeIntoAccount || exchangeToWaves) && signedByAdmin)
        || multiSignedByAdmins
      case _ => multiSignedByAdmins
  }
}