{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let version = "2.0.0"

let kVersion = "version"
let kActive = "active"
let kActiveGlob = "active_all_contracts"
let kDeprecated = "deprecated_"
let kAssetIdA = "A_asset_id"
let kAssetIdB = "B_asset_id"
let kBalanceA = "A_asset_balance"
let kBalanceB = "B_asset_balance"
let kShareAssetId = "share_asset_id"
let kShareAssetSupply = "share_asset_supply"
let kFee = "commission"
let kInvariant = "invariant"
let kCause = "shutdown_cause"
let kUSDNAddress = "staking_usdnnsbt_address"
let kEURNAddress = "staking_eurn_address"
let kDiscounts = "discounts"
let kDiscountValues = "discount_values"
let kUserSwopInGov = "_SWOP_amount"
let kUserGSwopInGov = "_GSwop_amount"
let kFirstHarvest = "first_harvest"
let kFirstHarvestHeight = "first_harvest_height"
let kShareLimit = "share_limit_on_first_harvest"
let kBasePeriod = "base_period"
let kPeriodLength = "period_length"
let kStartHeight = "start_height"
let kDAppThreshold = "dApp_threshold" # if A > B max ratio default 3

let kAdminPubKey1 = "admin_pub_1"
let kAdminPubKey2 = "admin_pub_2"
let kAdminPubKey3 = "admin_pub_3"
let kAdminInvokePubKey = "admin_invoke_pub"
let kMoneyBoxAddress = "money_box_address"
let kTeamBoxAddress = "team_box_address"
let kGovAddress = "governance_address"
let kFarmingAddress = "farming_address"
let kVotingAddress = "voting_address"
let kUSDNAssetId = "usdn_asset_id"
let kStakingAssets = "staking_assets"


let oracle = Address(base58'3PEbqViERCoKnmcSULh6n2aiMvUdSQdCsom')

func getBase58FromOracle(key: String) = match oracle.getString(key) {
    case string: String => string.fromBase58String()
    case nothing => throw(key + "is empty")
}

let adminPubKey1 = getBase58FromOracle(kAdminPubKey1)
let adminPubKey2 = getBase58FromOracle(kAdminPubKey2)
let adminPubKey3 = getBase58FromOracle(kAdminPubKey3)
let adminPubKeyInvoke = getBase58FromOracle(kAdminInvokePubKey)

let moneyBoxAddress = Address(getBase58FromOracle(kMoneyBoxAddress))
let teamBoxAddress = Address(getBase58FromOracle(kTeamBoxAddress))
let govAddress = Address(getBase58FromOracle(kGovAddress))
let stakingUSDNAddress = Address(getBase58FromOracle(kUSDNAddress))
let votingAddress = Address(getBase58FromOracle(kVotingAddress))
let farmingAddress = Address(getBase58FromOracle(kFarmingAddress))

let USDN = getBase58FromOracle(kUSDNAssetId)
let stakingAssets = oracle.getStringValue(kStakingAssets)

let basePeriod = votingAddress.getInteger(kBasePeriod).valueOrErrorMessage("Empty kBasePeriod") # 0
let startHeight = votingAddress.getInteger(kStartHeight).valueOrErrorMessage("Empty kStartHeight")
let periodLength =  votingAddress.getInteger(kPeriodLength).valueOrErrorMessage("Empty kPeriodLength")
let firstHarvestEndPeriod = basePeriod + (height-startHeight)/periodLength + 3
let active = this.getBooleanValue(kActive)
let activeGlob = oracle.getBoolean(kActiveGlob).valueOrElse(true)
let deprecatedPool = oracle.getBoolean(kDeprecated + this.toString()).valueOrElse(false)

let strAssetIdA = this.getStringValue(kAssetIdA)
let strAssetIdB = this.getStringValue(kAssetIdB)
let assetIdA = if strAssetIdA == "WAVES" then unit else strAssetIdA.fromBase58String()
let assetIdB = if strAssetIdB == "WAVES" then unit else strAssetIdB.fromBase58String()
let assetNameA = match assetIdA {
    case id: ByteVector => assetInfo(id).value().name
    case waves: Unit => "WAVES"
}
let assetNameB = match assetIdB {
    case id: ByteVector => assetInfo(id).value().name
    case waves: Unit => "WAVES"
}
let balanceA = this.getIntegerValue(kBalanceA)
let balanceB = this.getIntegerValue(kBalanceB)
let shareAssetId = this.getStringValue(kShareAssetId).fromBase58String()
let shareAssetSupply = this.getIntegerValue(kShareAssetSupply)
let invariant = this.getIntegerValue(kInvariant)

let fee = this.getIntegerValue(kFee)
let feeGovernance = fee.fraction(35, 100) #35% of fee send to the governance address
let feeTeam = fee.fraction(10, 100) #10% of fee send to the team box address
let feeScale6 = 1000000

let scale3 = 1000
let scale8 = 100000000
let scale16 = 10000000000000000
let digits8 = 8

let exchangeRatioLimitMin = 60000000 # 0.9*scale8. This parameter helps to avoid losses when an incorrect argument is passed
let exchangeRatioLimitMax = 140000000 #1.1*scale8. This parameter helps to avoid losses when an incorrect argument is passed

let alpha = 50 # model coefficient alpha = 0.15 with 2 digits
let alphaDigits = 2
let beta = 4600000000000000 # model coefficient beta = 0.46 with 16 digits

func accountBalance(assetId: ByteVector|Unit) = match assetId {
    case id: ByteVector => this.assetBalance(id)
    case waves: Unit => this.wavesBalance().available
}

func stakedAmount(assetId: ByteVector|Unit) = {
    let stakedAmountCalculated = match assetId {
        case aId: ByteVector =>
            if aId == USDN  then {
                stakingUSDNAddress.getInteger("rpd_balance_" + aId.toBase58String() + "_" + this.toString())
            } else 0
        case _:Unit => 0
    }
    match (stakedAmountCalculated) {
        case i:Int => i
        case _ => 0
    }
}

let stakedAmountA = stakedAmount(assetIdA)
let stakedAmountB = stakedAmount(assetIdB)
let availableBalanceA = balanceA - stakedAmountA
let availableBalanceB = balanceB - stakedAmountB
let accountBalanceWithStakedA = accountBalance(assetIdA) + stakedAmountA
let accountBalanceWithStakedB = accountBalance(assetIdB) + stakedAmountB

let hasEnoughBalance = accountBalanceWithStakedA >= balanceA && accountBalanceWithStakedB >= balanceB

# skewness = 0.5*(x/y+y/x)
# Each fraction multiple by scale in order to avoid zeroing
func skewness(x: Int, y: Int) = (scale16.fraction(x, y) + scale16.fraction(y, x)) / 2

# Calculate (x+y)*skewness^(-alpha) + 2*(x*y)^0.5*(skewness-beta)^alpha
func invariantCalc(x: Int, y: Int) = {
    let sk = skewness(x, y)
    fraction(
        x + y,
        scale16,
        pow(sk, digits8, alpha, alphaDigits, digits8, CEILING)
    ) + 2 * fraction(
        pow(fraction(x.toBigInt(), y.toBigInt(), scale8.toBigInt()), 0, 5.toBigInt(), 1, digits8 / 2, DOWN).toInt(),
        pow(sk - beta, digits8, alpha, alphaDigits, digits8, DOWN),
        scale8
    )
}

func calculateSendAmount(amountToSendEstimated: Int, minTokenReceiveAmount: Int, tokenReceiveAmount: Int, tokenId: ByteVector|Unit, balcA: Int, balcB: Int, invCur: Int) = {
    let worstAllowedNewInvariantRatio = scale16 - scale16 * 1 / 10000000 # 0.000001% of slippage
    let deltaBetweenMaxAndMinSendValue = amountToSendEstimated - minTokenReceiveAmount

    # only one of the variables will be used depending on the token
    let x = balcA + tokenReceiveAmount
    let y = balcB + tokenReceiveAmount

    func getStepAmount(acc: (Int, Int), step: Int) = {
        if acc._1 == -1 then
            let amountToSend = amountToSendEstimated - step * deltaBetweenMaxAndMinSendValue / 3 / scale3 # ATTENTION - Magic number in formula
            let stepInvariant =
            if tokenId == assetIdA then
                invariantCalc(x, balcB - amountToSend)
            else
                invariantCalc(balcA - amountToSend, y)

                if stepInvariant > invCur then
                    (amountToSend, stepInvariant)
                else
                    (-1, 0)
        else
            acc
    }

    let amountToSendMin = getStepAmount((-1, 0), 3000)
    if amountToSendMin._1 < 0 then
        throw("Price is worse than minReceived")
    else
        let invEstimated =
        if tokenId == assetIdA then
            invariantCalc(x, balcB - amountToSendEstimated)
        else if tokenId == assetIdB then
            invariantCalc(balcA - amountToSendEstimated, y)
        else throw("Wrong asset in payment")

        if invEstimated < invCur then
        # actual price is worse than estimated. Try to find matching price
            if (scale16.fraction(invCur, invEstimated) <= worstAllowedNewInvariantRatio) then
                throw("The requested price is too not profitable for user")
            else #
                let a = FOLD<3>([25, 200, 500], (-1, 0), getStepAmount)
                if (a._1 < 0) then
                    amountToSendMin._1
                else
                    a._1
        else
        # actual price is better than estimated. Try to find even better price
            let a = FOLD<3>([-500, -200, -25], (-1, 0), getStepAmount)
            let tupleSendBetter =
            if (a._1 < 0) then
                (amountToSendEstimated, invEstimated)
            else
                a
                if (scale16.fraction(invCur, tupleSendBetter._2) <= worstAllowedNewInvariantRatio) then
                    throw("The requested price is too not profitable for user")
                else
                    tupleSendBetter._1
}

func getAssetInfo(assetId: ByteVector|Unit) = match assetId {
    case id: ByteVector =>
        let stringId = id.toBase58String()
        let info = assetInfo(id).valueOrErrorMessage("Asset " + stringId + " doesn't exist")
        (stringId, info.name, info.decimals)
    case waves: Unit => ("WAVES", "WAVES", 8)
}

func suspend(cause: String) = [
    BooleanEntry(kActive, false),
    StringEntry(kCause, cause)
]

func throwIsActive() = throw("DApp is already active")

func isActive() = if active && activeGlob then unit else throw("DApp is inactive at this moment")

func isDepricated() = if !deprecatedPool then unit else throw("Pool is deprecated. Only withdraw action allowed.")

func isAdminCall(i:Invocation) = if [adminPubKey1, adminPubKey2, adminPubKey3].containsElement(i.callerPublicKey) then unit
else throw("Only admin can call this function")

func isSelfCall(i:Invocation) = if this == i.caller then unit else
    throw("Only contract itself can call this function")

    func throwAssets() = throw("Incorrect assets attached. Expected: " + strAssetIdA + " and " + strAssetIdB)

    func throwOnePayment() = throw("One attached payment expected")

    func suspendSuspicious() = suspend("Suspicious state. Actual balances: " + balanceA.toString() + " " + assetNameA + ", " + balanceB.toString() + " " + assetNameB
    + ". State: " + accountBalance(assetIdA).toString() + " " + assetNameA + ", " + accountBalance(assetIdB).toString() + " " + assetNameB)

    func calcStakingFuncAndAddres(stake: Boolean, assetId: ByteVector) = {
        if stake then
            ("lockNeutrino", stakingUSDNAddress)
        else
            ("unlockNeutrino", stakingUSDNAddress)
    }

    func calcStakingParams(stake: Boolean, amount:Int, assetId: ByteVector) = {
        if stake then
            let (call, stakingAddr) = calcStakingFuncAndAddres(stake, assetId)
            (call, stakingAddr, [], [AttachedPayment(assetId, amount)])
        else
            let (call, stakingAddr) = calcStakingFuncAndAddres(stake, assetId)
            (call, stakingAddr, [amount, assetId.toBase58String()], [])
    }

    func calculateFeeDiscount(userAddr: Address) = {
        let swopAmount = govAddress.getInteger(userAddr.toString() + kUserSwopInGov).valueOrElse(0)
        let gSwopAmount = govAddress.getInteger(userAddr.toString() + kUserGSwopInGov).valueOrElse(swopAmount)
        let discountValues = oracle.getStringValue(kDiscountValues).split(",")
        let discounts = oracle.getStringValue(kDiscounts).split(",")

        if gSwopAmount >= parseIntValue(discountValues[0]) && gSwopAmount < parseIntValue(discountValues[1]) then
            feeScale6 - parseIntValue(discounts[0])
        else if gSwopAmount >= parseIntValue(discountValues[1]) && gSwopAmount < parseIntValue(discountValues[2]) then
            feeScale6 - parseIntValue(discounts[1])
        else if gSwopAmount >= parseIntValue(discountValues[2]) && gSwopAmount < parseIntValue(discountValues[3]) then
            feeScale6 - parseIntValue(discounts[2])
        else if gSwopAmount >= parseIntValue(discountValues[3]) && gSwopAmount < parseIntValue(discountValues[4]) then
            feeScale6 - parseIntValue(discounts[3])
        else if gSwopAmount >= parseIntValue(discountValues[4]) then
            feeScale6 - parseIntValue(discounts[4])
        else
            feeScale6
    }

    func checkDAppThreshold(newBalanceA: Int, newBalanceB: Int, pmtAssetId: ByteVector|Unit) = {
        let dAppThreshold = this.getIntegerValue(kDAppThreshold)
        let ratio = if pmtAssetId == assetIdA && newBalanceA > newBalanceB then
            fraction(newBalanceA, 1, newBalanceB, CEILING)
        else if pmtAssetId == assetIdB && newBalanceB > newBalanceA then
            fraction(newBalanceB, 1, newBalanceA, CEILING)
        else
            0
            if ratio > dAppThreshold then
                let (token1, token2) = if pmtAssetId == assetIdA then (assetNameB, assetNameA) else (assetNameA, assetNameB)
                throw("Buying " + token1 + " is temporarily unavailable due to the " + token2 + " depeg")
            else
                true
    }

    func replenishWithTwoTokensCalc(i:Invocation, stakeFarming: Boolean, lockType: Int) = {
        let pmtAssetIdA = i.payments[0].assetId
        let pmtAssetIdB = i.payments[1].assetId
        let ratioShareTokensInA = scale8.fraction(i.payments[0].amount, balanceA)
        let ratioShareTokensInB = scale8.fraction(i.payments[1].amount, balanceB)
        let (pmtStrAssetIdA, pmtAssetNameA, pmtDecimalsA) = getAssetInfo(pmtAssetIdA)
        let (pmtStrAssetIdB, pmtAssetNameB, pmtDecimalsB) = getAssetInfo(pmtAssetIdB)

        #calc change if ratio is not valid
        let (pmtAmountA, pmtAmountB, change, changeAssetId, shareTokenRatio) =
        if(ratioShareTokensInA < ratioShareTokensInB) then
            let pmt = fraction(balanceB, ratioShareTokensInA, scale8, CEILING)
            (i.payments[0].amount, pmt, i.payments[1].amount - pmt, pmtAssetIdB, ratioShareTokensInA)
        else
            let pmt = fraction(balanceA, ratioShareTokensInB, scale8, CEILING)
            (pmt, i.payments[1].amount, i.payments[0].amount - pmt, pmtAssetIdA, ratioShareTokensInB)

            let shareTokenToPayAmount = shareTokenRatio.fraction(shareAssetSupply, scale8)

            if i.payments.size() != 2 && i.payments.size() != 3 then
                throw("Two or three payments expected")
            else if pmtAssetIdA != assetIdA || pmtAssetIdB != assetIdB then
                throwAssets()
            else if shareTokenToPayAmount == 0 then
                throw("Too small amount to replenish")
            else if change < 0 then
                throw("Change < 0")
            else if !hasEnoughBalance then
                [
                    ScriptTransfer(i.caller, pmtAmountA, pmtAssetIdA),
                    ScriptTransfer(i.caller, pmtAmountB, pmtAssetIdB)
                ] ++ suspendSuspicious()
            else
                strict stake1 =
                if stakingAssets.contains(pmtStrAssetIdA) then
                    invoke(this, "stakeUnstake", [true, pmtAmountA, pmtStrAssetIdA], [])
                else
                    0
                    strict stake2 =
                    if stakingAssets.contains(pmtStrAssetIdB) then
                        invoke(this, "stakeUnstake", [true, pmtAmountB, pmtStrAssetIdB], [])
                    else
                        0
                        let scriptActions = [
                            IntegerEntry(kBalanceA, balanceA + pmtAmountA),
                            IntegerEntry(kBalanceB, balanceB + pmtAmountB),
                            IntegerEntry(kShareAssetSupply, shareAssetSupply + shareTokenToPayAmount),
                            IntegerEntry(kInvariant, invariantCalc(balanceA + pmtAmountA, balanceB + pmtAmountB)),
                            ScriptTransfer(i.caller, change, changeAssetId)
                        ]
                        if stakeFarming then
                            let stPayments = [AttachedPayment(shareAssetId, shareTokenToPayAmount)] ++
                            if i.payments.size() == 3 then
                                [AttachedPayment(if i.payments[2].assetId == base58'' then unit else i.payments[2].assetId, i.payments[2].amount)]
                            else []
                            strict re = invoke(this, "reissueShare", [shareTokenToPayAmount], [])
                            strict s = invoke(farmingAddress, "lockShareTokensFromPool", [i.caller.bytes, this.toString(), lockType], stPayments)
                            scriptActions
                        else
                            scriptActions ++
                            [
                                Reissue(shareAssetId, shareTokenToPayAmount, true),
                                ScriptTransfer(i.caller, shareTokenToPayAmount, shareAssetId)
                            ]
    }

    func replenishWithOneTokenCalc(i:Invocation, virtualSwapTokenPay: Int, virtualSwapTokenGet: Int, stakeFarming: Boolean, lockType: Int) = {
        let (pmtAmount, pmtAssetId) = (i.payments[0].amount, i.payments[0].assetId)
        let (pmtStrAssetId, pmtAssetName, pmtDecimals) = getAssetInfo(pmtAssetId)

        let pmtMinThreshold = 5000000
        let thresholdValueForMinTolerance = 50000000
        let tolerance =
        if pmtAmount < thresholdValueForMinTolerance then
            100000
        else
            1

            let slippageValueMinForReplenish = scale8 - scale8 * tolerance / 10000000 # if pmtAmount > 50.000000 then slippage = 0.000001%
            let slippageValueMaxForReplenish = scale8 + scale8 * tolerance / 10000000

            let slippageValueMinForSwap = scale8 - scale8 * 1 / 10000000

            if pmtAmount < pmtMinThreshold then
                throw("Payment amount " + pmtAmount.toString() + " does not exceed the minimum amount of " + pmtMinThreshold.toString() + " tokens")
            else if i.payments.size() != 1 && i.payments.size() != 2 then throw("One or two payments expected")
            else if !hasEnoughBalance then
                [
                    ScriptTransfer(i.caller, pmtAmount, pmtAssetId)
                ] ++ suspendSuspicious()
            else if pmtAssetId != assetIdA && pmtAssetId != assetIdB then throwAssets() else
                let (virtualReplenishA, virtualReplenishB,
                balanceAfterSwapA, balanceAfterSwapB,
                newBalanceA, newBalanceB) =
                if pmtAssetId == assetIdA then (
                    pmtAmount - virtualSwapTokenPay, virtualSwapTokenGet,
                    balanceA + virtualSwapTokenPay, balanceB - virtualSwapTokenGet,
                    balanceA + pmtAmount, balanceB
                ) else (
                    virtualSwapTokenGet, pmtAmount - virtualSwapTokenPay,
                    balanceA - virtualSwapTokenGet, balanceB + virtualSwapTokenPay,
                    balanceA, balanceB + pmtAmount
                )

                let invariantNew = invariantCalc(balanceAfterSwapA, balanceAfterSwapB)
                let ratioVirtualBalanceToVirtualReplenish = (scale16).fraction(balanceAfterSwapA, balanceAfterSwapB)
                / scale8.fraction(virtualReplenishA, virtualReplenishB)

                if scale8.fraction(invariant, invariantNew) <= slippageValueMinForSwap || invariantNew < invariant then
                    throw("Incorrect virtualSwapTokenPay or virtualSwapTokenGet value")
                else if ratioVirtualBalanceToVirtualReplenish < slippageValueMinForReplenish || ratioVirtualBalanceToVirtualReplenish > slippageValueMaxForReplenish then
                    throw("Swap with virtualSwapTokenPay and virtualSwapTokenGet is possible, but ratio after virtual swap is incorrect")
                else if !checkDAppThreshold(newBalanceA, newBalanceB, pmtAssetId) then throw() else
                # fee for staking operation
                    let ratioShareTokensInA = virtualReplenishA.fraction(scale8, balanceAfterSwapA)
                    let ratioShareTokensInB = virtualReplenishB.fraction(scale8, balanceAfterSwapB)

                    let shareTokenToPayAmount = min([ratioShareTokensInA, ratioShareTokensInB]).fraction(shareAssetSupply, scale8)
                    # fee for operation is devided by 2 to account internal swap fee. Only half of tokens took part in virtual exchange
                    let shareTokenToPayAmountAfterFee = shareTokenToPayAmount.fraction(feeScale6 - fee/2, feeScale6)
                    let shareTokenGovernanceReward = shareTokenToPayAmount.fraction(feeGovernance/2, feeScale6)
                    let shareTokenTeamReward = shareTokenToPayAmount.fraction(feeTeam/2, feeScale6)
                    let governanceRewardTokenA = shareTokenGovernanceReward.fraction(balanceA, shareAssetSupply)
                    let governanceRewardTokenB = shareTokenGovernanceReward.fraction(balanceB, shareAssetSupply)
                    let teamRewardTokenA = shareTokenTeamReward.fraction(balanceA, shareAssetSupply)
                    let teamRewardTokenB = shareTokenTeamReward.fraction(balanceB, shareAssetSupply)

                    let (stakeAmount, unstakeAmount, unstakeAsset) = if(pmtStrAssetId == strAssetIdA) then
                        (pmtAmount - governanceRewardTokenA - teamRewardTokenA, governanceRewardTokenB + teamRewardTokenB, strAssetIdB)
                    else
                        (pmtAmount - governanceRewardTokenB - teamRewardTokenB, governanceRewardTokenA + teamRewardTokenA, strAssetIdA)
                        strict stake1 =
                        if stakingAssets.contains(pmtStrAssetId) then
                            invoke(this, "stakeUnstake", [true, stakeAmount, pmtStrAssetId], [])
                        else
                            0

                            strict stake2 =
                            if stakingAssets.contains(unstakeAsset) then
                                invoke(this, "stakeUnstake", [false, unstakeAmount, unstakeAsset], [])
                            else
                                0
                                let scriptActions = [
                                    IntegerEntry(kBalanceA, newBalanceA - governanceRewardTokenA - teamRewardTokenA),
                                    IntegerEntry(kBalanceB, newBalanceB - governanceRewardTokenB - teamRewardTokenB),
                                    IntegerEntry(kShareAssetSupply, shareAssetSupply + shareTokenToPayAmountAfterFee),
                                    IntegerEntry(kInvariant, invariantCalc(newBalanceA - governanceRewardTokenA, newBalanceB - governanceRewardTokenB)),
                                    ScriptTransfer(moneyBoxAddress, governanceRewardTokenA, assetIdA),
                                    ScriptTransfer(moneyBoxAddress, governanceRewardTokenB, assetIdB),
                                    ScriptTransfer(teamBoxAddress, teamRewardTokenA, assetIdA),
                                    ScriptTransfer(teamBoxAddress, teamRewardTokenB, assetIdB)
                                ]
                                if stakeFarming then
                                    let stPayments = [AttachedPayment(shareAssetId, shareTokenToPayAmountAfterFee)] ++
                                    if i.payments.size() == 2 then
                                        [AttachedPayment(if i.payments[1].assetId == base58'' then unit else i.payments[1].assetId, i.payments[1].amount)]
                                    else []
                                    strict re = invoke(this, "reissueShare", [shareTokenToPayAmountAfterFee], [])
                                    strict s = invoke(farmingAddress, "lockShareTokensFromPool", [i.caller.bytes, this.toString(), lockType], stPayments)
                                    scriptActions
                                else
                                    scriptActions ++
                                    [
                                        Reissue(shareAssetId, shareTokenToPayAmountAfterFee, true),
                                        ScriptTransfer(i.caller, shareTokenToPayAmountAfterFee, shareAssetId)
                                    ]
    }

    func withdrawCalc(i: Invocation, unlockAmount: Int) = {
        let (pmtAmount, pmtAssetId) = if(i.payments.size() == 1) then
            if i.payments[0].assetId != shareAssetId then
                throw("Incorrect asset attached. Expected: " + shareAssetId.toBase58String())
            else
                (i.payments[0].amount, i.payments[0].assetId)
        else
            (0, shareAssetId)
            if !hasEnoughBalance then
                [
                    ScriptTransfer(i.caller, pmtAmount, pmtAssetId)
                ] ++ suspendSuspicious()
            else
                strict unlock = if(unlockAmount > 0) then
                    invoke(farmingAddress, "withdrawShareTokensFromPool", [i.caller.bytes, this.toString(), unlockAmount], []) else 0
                let withdrawAmount = pmtAmount + unlockAmount
                let amountToPayA = withdrawAmount.fraction(balanceA, shareAssetSupply)
                let amountToPayB = withdrawAmount.fraction(balanceB, shareAssetSupply)
                let invariantCalculated = invariantCalc(balanceA - amountToPayA, balanceB - amountToPayB)
                strict stake1 =
                if stakingAssets.contains(strAssetIdA) then
                    invoke(this, "stakeUnstake", [false, amountToPayA, strAssetIdA], [])
                else
                    0
                    strict stake2 =
                    if stakingAssets.contains(strAssetIdB) then
                        invoke(this, "stakeUnstake", [false, amountToPayB, strAssetIdB], [])
                    else
                        0
                        [
                            IntegerEntry(kBalanceA, balanceA - amountToPayA),
                            IntegerEntry(kBalanceB, balanceB - amountToPayB),
                            IntegerEntry(kShareAssetSupply, shareAssetSupply - withdrawAmount),
                            IntegerEntry(kInvariant, invariantCalculated),
                            Burn(shareAssetId, withdrawAmount),
                            ScriptTransfer(i.caller, amountToPayA, assetIdA),
                            ScriptTransfer(i.caller, amountToPayB, assetIdB)
                        ]
    }

    @Callable(i)
    func init(firstHarvest: Boolean) = {
        let (pmtAmountA, pmtAssetIdA) = (i.payments[0].amount, i.payments[0].assetId)
        let (pmtAmountB, pmtAssetIdB) = (i.payments[1].amount, i.payments[1].assetId)
        let (pmtStrAssetIdA, pmtAssetNameA, pmtDecimalsA) = getAssetInfo(pmtAssetIdA)
        let (pmtStrAssetIdB, pmtAssetNameB, pmtDecimalsB) = getAssetInfo(pmtAssetIdB)

        if this.getBoolean(kActive).isDefined() then
            throwIsActive()
        else if pmtAssetIdA == pmtAssetIdB then
            throw("Assets must be different")
        else {
            let shareName = "s" + pmtAssetNameA.take(7) + "_" + pmtAssetNameB.take(7)
            let shareDescription = "ShareToken of SwopFi protocol for " + pmtAssetNameA + " and " + pmtAssetNameB + " at address " + this.toString()

            # we save 16 digit info with using digits8 in pow functions. We divide /scale8 to delete 8 digits and another 8 digits we define as digits in shareToken in Issue tx
            let shareDecimals = (pmtDecimalsA + pmtDecimalsB) / 2
            let shareInitialSupply = fraction(
                pow(pmtAmountA, pmtDecimalsA, 5, 1, pmtDecimalsA, DOWN),
                pow(pmtAmountB, pmtDecimalsB, 5, 1, pmtDecimalsB, DOWN),
                pow(10, 0, shareDecimals, 0, 0, DOWN)
            )
            let shareIssue = Issue(shareName, shareDescription, shareInitialSupply, shareDecimals, true)
            let shareIssueId = shareIssue.calculateAssetId()

            let invariantCalculated = invariantCalc(pmtAmountA, pmtAmountB)
            strict stake1 =
            if stakingAssets.contains(pmtStrAssetIdA) then
                invoke(this, "stakeUnstake", [true, pmtAmountA, pmtStrAssetIdA], [])
            else
                0
                strict stake2 =
                if stakingAssets.contains(pmtStrAssetIdB) then
                    invoke(this, "stakeUnstake", [true, pmtAmountB, pmtStrAssetIdB], [])
                else
                    0
                    let baseEntry = [
                        StringEntry(kVersion, version),
                        BooleanEntry(kActive, true),
                        StringEntry(kAssetIdA, pmtStrAssetIdA),
                        StringEntry(kAssetIdB, pmtStrAssetIdB),
                        IntegerEntry(kBalanceA, pmtAmountA),
                        IntegerEntry(kBalanceB, pmtAmountB),
                        IntegerEntry(kInvariant, invariantCalculated),
                        IntegerEntry(kFee, oracle.getIntegerValue("base_fee_flat")),
                        IntegerEntry(kDAppThreshold, 3),
                        shareIssue,
                        StringEntry(kShareAssetId, shareIssueId.toBase58String()),
                        IntegerEntry(kShareAssetSupply, shareInitialSupply),
                        ScriptTransfer(i.caller, shareInitialSupply, shareIssueId)
                    ]
                    if (firstHarvest) then {
                        baseEntry ++ [
                            BooleanEntry(kFirstHarvest, firstHarvest),
                            IntegerEntry(kFirstHarvestHeight, startHeight + firstHarvestEndPeriod * periodLength)
                        ]
                    } else {
                        baseEntry
                    }
        }
    }

    # if someone ready to replenish in both tokens. It's necessary to bring tokens amount in proportion according to dApp state
    @Callable(i)
    func replenishWithTwoTokensV2(stakeFarming: Boolean, lockType: Int) =
    isActive().valueOrElse({
        isDepricated().valueOrElse({
            replenishWithTwoTokensCalc(i, stakeFarming, lockType)
        })})

    # if someone ready to replenish in one token
    @Callable(i)
    func replenishWithOneTokenV2(virtualSwapTokenPay: Int, virtualSwapTokenGet: Int, stakeFarming: Boolean, lockType: Int) =
    isActive().valueOrElse({
        isDepricated().valueOrElse({
            replenishWithOneTokenCalc(i, virtualSwapTokenPay, virtualSwapTokenGet, stakeFarming, lockType)
        })})

    @Callable(i)
    func withdrawV2(unlockAmount: Int) =
    isActive().valueOrElse({
        withdrawCalc(i, unlockAmount)
    })

    @Callable(i)
    func withdrawOneToken(unlockAmount: Int, withdrawAsset: String, estimatedAmountToReceive: Int, minAmountToReceive: Int) =
    isActive().valueOrElse({
        isDepricated().valueOrElse({
            let (pmtAmount, pmtAssetId) = if(i.payments.size() == 1) then
                if i.payments[0].assetId != shareAssetId then
                    throw("Incorrect asset attached. Expected: " + shareAssetId.toBase58String())
                else
                    (i.payments[0].amount, i.payments[0].assetId)
            else
                (0, shareAssetId)
                let withdrawAmount = pmtAmount + unlockAmount
                if withdrawAsset != strAssetIdA && withdrawAsset != strAssetIdB then throw("Incorrect withdraw asset") else
                if withdrawAmount <= 0 then throw("withdraw amount must be grater than 0") else
                if !hasEnoughBalance then
                    [
                        ScriptTransfer(i.caller, pmtAmount, pmtAssetId)
                    ] ++ suspendSuspicious()
                else
                    strict unlock = if(unlockAmount > 0) then
                        invoke(farmingAddress, "withdrawShareTokensFromPool", [i.caller.bytes, this.toString(), unlockAmount], []) else 0
                    let amountToPayA = withdrawAmount.fraction(balanceA, shareAssetSupply)
                    let amountToPayB = withdrawAmount.fraction(balanceB, shareAssetSupply)
                    let newVirtBalcA = balanceA - amountToPayA
                    let newVirtBalcB = balanceB - amountToPayB
                    let feeDiscount = calculateFeeDiscount(i.originCaller)
                    let amountExchangedWithFee = if (withdrawAsset == strAssetIdA) then
                        calculateSendAmount(estimatedAmountToReceive, minAmountToReceive, amountToPayB, assetIdB, newVirtBalcA, newVirtBalcB, invariantCalc(newVirtBalcA, newVirtBalcB))
                    else
                        calculateSendAmount(estimatedAmountToReceive, minAmountToReceive, amountToPayA, assetIdA, newVirtBalcA, newVirtBalcB, invariantCalc(newVirtBalcA, newVirtBalcB))
                        let govReward = amountExchangedWithFee.fraction(feeGovernance.fraction(feeDiscount, feeScale6, CEILING), feeScale6)
                        let teamReward = amountExchangedWithFee.fraction(feeTeam.fraction(feeDiscount, feeScale6, CEILING), feeScale6)
                        let amountExchanged = amountExchangedWithFee.fraction(feeScale6 - fee.fraction(feeDiscount, feeScale6, CEILING), feeScale6)
                        let (amountToPay, balanceANew, balanceBNew, virtAssetId) = if (withdrawAsset == strAssetIdA) then
                            (amountToPayA + amountExchanged, balanceA - amountToPayA - amountExchanged - govReward - teamReward, balanceB, assetIdB)
                        else
                            (amountToPayB + amountExchanged, balanceA, balanceB - amountToPayB - amountExchanged - govReward - teamReward, assetIdA)

                            if !checkDAppThreshold(balanceANew, balanceBNew, virtAssetId) then throw() else

                                let invariantCalculated = invariantCalc(balanceANew, balanceBNew)
                                strict stake1 =
                                if stakingAssets.contains(withdrawAsset) then
                                    invoke(this, "stakeUnstake", [false, amountToPay + govReward + teamReward, withdrawAsset], [])
                                else 0
                                [
                                    IntegerEntry(kBalanceA, balanceANew),
                                    IntegerEntry(kBalanceB, balanceBNew),
                                    IntegerEntry(kShareAssetSupply, shareAssetSupply - withdrawAmount),
                                    IntegerEntry(kInvariant, invariantCalculated),
                                    Burn(shareAssetId, withdrawAmount),
                                    ScriptTransfer(i.caller, amountToPay, withdrawAsset.fromBase58String()),
                                    ScriptTransfer(moneyBoxAddress, govReward, withdrawAsset.fromBase58String()),
                                    ScriptTransfer(teamBoxAddress, teamReward, withdrawAsset.fromBase58String())
                                ]
        })})

    @Callable(i)
    func exchange(estimatedAmountToReceive: Int, minAmountToReceive: Int) =
    isActive().valueOrElse({
        isDepricated().valueOrElse({
            let (pmtAmount, pmtAssetId) = (i.payments[0].amount, i.payments[0].assetId)

            if estimatedAmountToReceive <= 0 then
                throw("Estimated amount must be positive. Actual: " + estimatedAmountToReceive.toString())
            else if minAmountToReceive > estimatedAmountToReceive then
                throw("Minimal amount can't be greater than estimated.")
            else if i.payments.size() != 1 then
                throwOnePayment()
            else if !hasEnoughBalance then
                [
                    ScriptTransfer(i.caller, pmtAmount, pmtAssetId)
                ] ++ suspendSuspicious()
            else if pmtAssetId != assetIdA && pmtAssetId != assetIdB then
                throwAssets()
            else if pmtAmount < 10000000 then
                throw("Only swap of 10.000000 or more tokens is allowed")
            else if scale8.fraction(minAmountToReceive, pmtAmount) < exchangeRatioLimitMin ||
            scale8.fraction(estimatedAmountToReceive, pmtAmount) > exchangeRatioLimitMax then
                throw("Incorrect args and pmt ratio")
            else {
                let sendAssetId =
                if pmtAssetId == assetIdA then
                    assetIdB
                else
                    assetIdA

                    let amount = calculateSendAmount(estimatedAmountToReceive, minAmountToReceive, pmtAmount, pmtAssetId, balanceA, balanceB, invariant)
                    let feeDiscount = calculateFeeDiscount(i.originCaller)
                    let governanceReward = amount.fraction(feeGovernance.fraction(feeDiscount, feeScale6, CEILING), feeScale6)
                    let teamReward = amount.fraction(feeTeam.fraction(feeDiscount, feeScale6, CEILING), feeScale6)
                    let amountMinusFee = amount.fraction(feeScale6 - fee.fraction(feeDiscount, feeScale6, CEILING), feeScale6)

                    let (newBalanceA, newBalanceB) =
                    if pmtAssetId == assetIdA then
                        (balanceA + pmtAmount, balanceB - amountMinusFee - governanceReward - teamReward)
                    else
                        (balanceA - amountMinusFee - governanceReward - teamReward, balanceB + pmtAmount)

                        if !checkDAppThreshold(newBalanceA, newBalanceB, pmtAssetId) then throw() else

                            let (pmtStrAssetId, pmtAssetName, pmtDecimals) = getAssetInfo(pmtAssetId)
                            let (sendStrAssetId, sendAssetName, sendDecimals) = getAssetInfo(sendAssetId)
                            strict stake1 =
                            if stakingAssets.contains(pmtStrAssetId) then
                                invoke(this, "stakeUnstake", [true, pmtAmount, pmtStrAssetId], [])
                            else
                                0
                                strict stake2 =
                                if stakingAssets.contains(sendStrAssetId) then
                                    invoke(this, "stakeUnstake", [false, amountMinusFee + governanceReward + teamReward, sendStrAssetId], [])
                                else
                                    0

                                    # successful execution result is updating information about actual balance and supply into the state and transfer tokens to the caller
                                    (
                                        [
                                            IntegerEntry(kBalanceA, newBalanceA),
                                            IntegerEntry(kBalanceB, newBalanceB),
                                            IntegerEntry(kInvariant, invariantCalc(newBalanceA, newBalanceB)),
                                            ScriptTransfer(i.caller, amountMinusFee, sendAssetId),
                                            ScriptTransfer(moneyBoxAddress, governanceReward, sendAssetId),
                                            ScriptTransfer(teamBoxAddress, teamReward, sendAssetId)
                                        ],
                                        [amountMinusFee, sendAssetId]
                                    )
            }
        })})

    @Callable(msg)
    func reissueShare(amount:Int) =
    isSelfCall(msg).valueOrElse({
        [Reissue(shareAssetId, amount, true)]
    })

    @Callable(i)
    func shutdown() =
    isAdminCall(i).valueOrElse({
        if !active then
            throw("DApp is already suspended. Cause: " + this.getString(kCause).valueOrElse("the cause wasn't specified"))
        else
            suspend("Paused by admin")
    })

    @Callable(i)
    func activate() =
    isAdminCall(i).valueOrElse({
        if active then
            throwIsActive()
        else
            [
                BooleanEntry(kActive, true),
                DeleteEntry(kCause)
            ]
    })

    @Callable(i)
    func takeIntoAccountExtraFunds() =
    isActive().valueOrElse({
        strict claim = if assetIdA == USDN || assetIdB == USDN then
            invoke(stakingUSDNAddress, "claimRewards", [], [])
        else 0
        let amountEnrollA = accountBalanceWithStakedA - balanceA
        let amountEnrollB = accountBalanceWithStakedB - balanceB
        let invariantNew = invariantCalc(balanceA + amountEnrollA, balanceB + amountEnrollB)

        if i.caller != moneyBoxAddress then
            throw("Only the money box can call this function")
        else if amountEnrollA < 0 || amountEnrollB < 0 then
            suspend("Enroll amount negative")
        else if amountEnrollA == 0 && amountEnrollB == 0 then
            throw("No money to take")
        else
            strict stake1 =
            if stakingAssets.contains(strAssetIdA) && amountEnrollA > 0 then
                invoke(this, "stakeUnstake", [true, amountEnrollA, strAssetIdA], [])
            else
                0
                strict stake2 =
                if stakingAssets.contains(strAssetIdB)  && amountEnrollB > 0 then
                    invoke(this, "stakeUnstake", [true, amountEnrollB, strAssetIdB], [])
                else
                    0
                    [
                        IntegerEntry(kInvariant, invariantNew),
                        IntegerEntry(kBalanceA, balanceA + amountEnrollA),
                        IntegerEntry(kBalanceB, balanceB + amountEnrollB)
                    ]
    })

    @Callable(i)
    func keepLimitForFirstHarvest(shareLimit: Int) =
    isActive().valueOrElse({
        isAdminCall(i).valueOrElse({
            [
                IntegerEntry(kShareLimit, shareLimit)
            ]
        })})



    @Callable(i)
    func stakeUnstake(stake:Boolean, amount: Int, assetIdString:String) = {
        if i.caller != this then
            throw("Only contract itself can invoke this function")
        else
            let (call, addr, params, payments) = calcStakingParams(stake, amount, assetIdString.fromBase58String())
            strict inv = invoke(addr, call, params, payments)
            []
    }

    @Verifier(tx)
    func verify() = {
        let multiSignedByAdmins = {
            let adminPubKey1Signed = if sigVerify(tx.bodyBytes, tx.proofs[0], adminPubKey1) then 1 else 0
            let adminPubKey2Signed = if sigVerify(tx.bodyBytes, tx.proofs[1], adminPubKey2) then 1 else 0
            let adminPubKey3Signed = if sigVerify(tx.bodyBytes, tx.proofs[2], adminPubKey3) then 1 else 0
            adminPubKey1Signed + adminPubKey2Signed + adminPubKey3Signed >= 2
        }
        match tx {
            case inv: InvokeScriptTransaction =>
                let callTakeIntoAccount = inv.dApp == this && inv.function == "takeIntoAccountExtraFunds"
                let signedByAdmin =
                sigVerify(tx.bodyBytes, tx.proofs[0], adminPubKey1)
                || sigVerify(tx.bodyBytes, tx.proofs[0], adminPubKey2)
                || sigVerify(tx.bodyBytes, tx.proofs[0], adminPubKey3)
                || sigVerify(tx.bodyBytes, tx.proofs[0], adminPubKeyInvoke)

                (callTakeIntoAccount && signedByAdmin)
                || multiSignedByAdmins
            case _ => multiSignedByAdmins
        }
    }

    #!!!!!!!!!!!!!!!!!DEPRECATED FUNCTIONS START!!!!!!!!!!!!!!!!!

    @Callable(i)
    func replenishWithTwoTokens() =
    isActive().valueOrElse({
        isDepricated().valueOrElse({
            replenishWithTwoTokensCalc(i, false, 0)
        })})

    @Callable(i)
    func replenishWithOneToken(virtualSwapTokenPay: Int, virtualSwapTokenGet: Int) =
    isActive().valueOrElse({
        isDepricated().valueOrElse({
            replenishWithOneTokenCalc(i, virtualSwapTokenPay, virtualSwapTokenGet, false, 0)
        })})

    @Callable(i)
    func withdraw() =
    isActive().valueOrElse({
        withdrawCalc(i, 0)
    })

#!!!!!!!!!!!!!!!!!DEPRECATED FUNCTIONS END!!!!!!!!!!!!!!!!!